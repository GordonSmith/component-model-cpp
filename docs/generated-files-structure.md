# Generated Files Structure

The WIT code generator produces three files to support WAMR host applications:

## Generated Files

### 1. `sample.hpp` - Component Model Interface Declarations

**Purpose:** Declares all Component Model interfaces (imports and exports) with C++ type mappings.

**Contents:**
- Namespace `host` - Functions the host must implement (imported by guest)
- Namespace `guest` - Functions the guest implements (exported by guest)
- Type aliases for all guest function signatures (e.g., `guest::booleans::and_t`)
- Local type definitions (variants, enums, records)

**Example:**
```cpp
namespace host {
    namespace booleans {
        cmcpp::bool_t and_(cmcpp::bool_t a, cmcpp::bool_t b);
    }
}

namespace guest {
    namespace booleans {
        using and_t = cmcpp::bool_t(cmcpp::bool_t, cmcpp::bool_t);
    }
}
```

**Usage:**
```cpp
#include "sample.hpp"
```

---

### 2. `sample_wamr.hpp` - WAMR Helper Function Declarations

**Purpose:** Declares utility functions for initializing and using WAMR with Component Model bindings.

**Contents:**
- `get_import_registrations()` - Get array of all import interfaces
- `register_all_imports()` - Register all imports at once
- `unregister_all_imports()` - Unregister all imports at cleanup
- `wasm_utils` namespace with:
  - `DEFAULT_STACK_SIZE` / `DEFAULT_HEAP_SIZE` constants
  - `resolve_wasm_path()` - Find WASM file in directory tree
  - `read_wasm_binary_to_buffer()` - Load WASM file into memory
  - `create_guest_realloc()` - Create GuestRealloc function
  - `create_lift_lower_context()` - Create complete LiftLowerContext

**Header Guard:**
```cpp
#ifndef GENERATED_WAMR_BINDINGS_HPP
#define GENERATED_WAMR_BINDINGS_HPP
```

**Includes:**
- `<wamr.hpp>` - WAMR runtime API
- `<cmcpp.hpp>` - Component Model C++ library
- `"sample.hpp"` - Your interface declarations
- Standard library headers (`<filesystem>`, `<vector>`, etc.)

**Usage:**
```cpp
#include "sample_wamr.hpp"  // Automatically includes sample.hpp
```

---

### 3. `sample_wamr.cpp` - WAMR Symbol Arrays and Implementations

**Purpose:** Implements the WAMR bindings and helper functions.

**Contents:**
- NativeSymbol arrays for each import interface
  - `booleans_symbols[]`
  - `floats_symbols[]`
  - `strings_symbols[]`
  - etc.
- Implementation of all functions declared in `sample_wamr.hpp`

**Example:**
```cpp
#include "sample_wamr.hpp"

NativeSymbol booleans_symbols[] = {
    host_function("and", imports::booleans::and_),
};

std::vector<NativeRegistration> get_import_registrations() {
    return {
        {"example:sample/booleans", booleans_symbols, 1},
        // ...
    };
}

namespace wasm_utils {
    const uint32_t DEFAULT_STACK_SIZE = 8192;
    const uint32_t DEFAULT_HEAP_SIZE = 8192;
    
    // ... implementations of all helper functions
}
```

**Build Integration:**
This file must be compiled and linked with your host application:
```cmake
add_executable(my_host
    main.cpp
    host_impl.cpp  # Your implementation of imports
    ${GENERATED_DIR}/sample_wamr.cpp  # Generated bindings
)
```

---

## File Dependencies

```
sample_wamr.cpp
    ↓ includes
sample_wamr.hpp
    ↓ includes
sample.hpp
```

Your host code only needs to include `sample_wamr.hpp` to get access to everything.

---

## Typical Project Structure

```
my-project/
├── CMakeLists.txt
├── main.cpp                    # Your main application
├── host_impl.cpp               # Your implementations of imports::*
└── generated/                  # Generated by WIT codegen
    ├── sample.hpp              # Interface declarations
    ├── sample_wamr.hpp         # Helper function declarations
    └── sample_wamr.cpp         # Symbol arrays & implementations
```

---

## What You Need to Implement

The generator creates the scaffolding, but you must provide:

1. **Host Function Implementations** (`host_impl.cpp`)
   - Implement all functions declared in the `host` namespace
   - Example: `host::booleans::and_()`

2. **Main Application Logic** (`main.cpp`)
   - Call `register_all_imports()` during initialization
   - Use `wasm_utils::*` helpers to set up WAMR
   - Call guest functions using `guest_function<>()`
   - Call `unregister_all_imports()` during cleanup

---

## Example: Complete Host Application

**host_impl.cpp** - Implement host functions:
```cpp
#include "sample.hpp"
#include <iostream>

namespace host {
    namespace booleans {
        cmcpp::bool_t and_(cmcpp::bool_t a, cmcpp::bool_t b) {
            return a && b;
        }
    }
    
    namespace logging {
        void log_str(cmcpp::string_t msg) {
            std::cout << "[HOST] " << msg << std::endl;
        }
    }
}
```

**main.cpp** - Use generated helpers:
```cpp
#include "sample_wamr.hpp"
#include <iostream>

int main(int argc, char** argv) {
    // Initialize WAMR
    wasm_runtime_init();
    
    // Find and load WASM file
    auto exe_dir = std::filesystem::absolute(argv[0]).parent_path();
    auto wasm_path = wasm_utils::resolve_wasm_path(exe_dir);
    if (wasm_path.empty()) {
        std::cerr << "WASM file not found" << std::endl;
        return 1;
    }
    
    uint32_t size;
    char* buffer = wasm_utils::read_wasm_binary_to_buffer(wasm_path, &size);
    if (!buffer) {
        std::cerr << "Failed to read WASM file" << std::endl;
        return 1;
    }
    
    // Register all host functions (imports)
    if (register_all_imports() < 0) {
        std::cerr << "Failed to register imports" << std::endl;
        delete[] buffer;
        return 1;
    }
    
    // Load and instantiate module
    char error_buf[128];
    auto module = wasm_runtime_load((uint8_t*)buffer, size, error_buf, sizeof(error_buf));
    auto module_inst = wasm_runtime_instantiate(
        module, wasm_utils::DEFAULT_STACK_SIZE, wasm_utils::DEFAULT_HEAP_SIZE,
        error_buf, sizeof(error_buf));
    
    // Create execution environment
    auto exec_env = wasm_runtime_create_exec_env(module_inst, wasm_utils::DEFAULT_STACK_SIZE);
    auto cabi_realloc = wasm_runtime_lookup_function(module_inst, "cabi_realloc");
    auto ctx = wasm_utils::create_lift_lower_context(module_inst, exec_env, cabi_realloc);
    
    // Call guest functions (exports)
    auto my_func = guest_function<guest::booleans::and_t>(
        module_inst, exec_env, ctx, "example:sample/booleans#and");
    
    std::cout << "Guest and(true, false) = " << my_func(true, false) << std::endl;
    
    // Cleanup
    delete[] buffer;
    wasm_runtime_destroy_exec_env(exec_env);
    unregister_all_imports();
    wasm_runtime_deinstantiate(module_inst);
    wasm_runtime_unload(module);
    wasm_runtime_destroy();
    
    return 0;
}
```

**CMakeLists.txt**:
```cmake
add_executable(my_host
    main.cpp
    host_impl.cpp
    ${CMAKE_CURRENT_BINARY_DIR}/generated/sample_wamr.cpp
)

target_include_directories(my_host PRIVATE
    ${CMAKE_CURRENT_BINARY_DIR}/generated
)
```

---

## Benefits of This Structure

1. **Clean Separation**: Interface declarations separate from implementation
2. **Header-only for Types**: Type definitions can be used without linking
3. **Standard C++ Practice**: Follows conventional `.hpp`/`.cpp` pattern
4. **No ODR Violations**: Functions defined in `.cpp` only, declarations in `.hpp`
5. **Easy Integration**: Single `#include "sample_wamr.hpp"` gets everything
6. **Documentation**: Function declarations in header serve as API documentation
7. **Compile-time Efficiency**: No inline bloat in header files

---

## Advanced: Using Only Parts of the Generated Code

If you want finer control, you can use the files individually:

**Option 1: Just the interfaces (no WAMR)**
```cpp
#include "sample.hpp"  // Get type definitions only
```

**Option 2: Manual WAMR setup**
```cpp
#include "sample.hpp"
#include <wamr.hpp>

// Don't include sample_wamr.hpp
// Manually register each interface as needed
```

**Option 3: Full generated helpers (recommended)**
```cpp
#include "sample_wamr.hpp"  // Everything you need
```
