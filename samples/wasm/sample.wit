package example:sample;

interface booleans {
  and: func(a: bool, b: bool) -> bool;
  // export or: func(a: bool, b: bool) -> bool;
  // export not: func(a: bool) -> bool;
}

interface floats {
  add: func(a: f64, b: f64) -> f64;
}

interface strings {
  reverse: func(a: string) -> string;
  lots: func(
    p1: string, p2: string, p3: string, p4: string, p5: string,
    p6: string, p7: string, p8: string, p9: string, p10: string,
    p11: string, p12: string, p13: string, p14: string, p15: string,
    p16: string, p17: string
  ) -> u32;
}

interface tuples {
  reverse: func(a: tuple<bool, string>) -> tuple<string, bool>;
}

interface lists {
  variant v {
    b(bool),
    s(string)
  }
  filter-bool: func(a: list<v>) -> list<string>;
}

interface variants {
  variant v {
    b(bool),
    u(u32)
  }
  variant-func: func(a: v) -> v;
}

interface enums {
  enum e {
    a,
    b,
    c
  }
  enum-func: func(a: e) -> e;
}

interface logging {
  log-bool: func(a: bool, s: string);
  log-u32: func(a: u32, s: string);
  log-u64: func(a: u64, s: string);
  log-f32: func(a: f32, s: string);
  log-f64: func(a: f64, s: string);
  log-str: func(a: string, s: string);
}

world sample {
  export booleans;
  export floats;
  export strings;
  export tuples;
  export lists;
  export variants;
  export enums;

  export void-func: func();
  export ok-func: func(a:u32, b:u32) -> result<u32, string>;
  export err-func: func(a:u32, b:u32) -> result<u32, string>;
  export option-func: func(a: option<u32>) -> option<u32>;
 
  import logging;
  import void-func: func();
  import booleans;
  import floats;
  import strings;
}
