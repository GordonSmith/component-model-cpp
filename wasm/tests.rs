// Generated by `wit-bindgen` 0.16.0. DO NOT EDIT!
#[allow(unused_unsafe, clippy::all)]
pub fn dbglog(msg: &str,){
  
  #[allow(unused_imports)]
  use wit_bindgen::rt::{alloc, vec::Vec, string::String};
  unsafe {
    let vec0 = msg;
    let ptr0 = vec0.as_ptr() as i32;
    let len0 = vec0.len() as i32;
    
    #[cfg(target_arch = "wasm32")]
    #[link(wasm_import_module = "$root")]
    extern "C" {
      #[link_name = "dbglog"]
      fn wit_import(_: i32, _: i32, );
    }
    
    #[cfg(not(target_arch = "wasm32"))]
    fn wit_import(_: i32, _: i32, ){ unreachable!() }
    wit_import(ptr0, len0);
  }
}
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "bool-and"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_bool_and(arg0: i32,arg1: i32,) -> i32 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::bool_and(wit_bindgen::rt::bool_lift(arg0 as u8), wit_bindgen::rt::bool_lift(arg1 as u8));
    match result0 { true => 1, false => 0 }
  }
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "bool-or"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_bool_or(arg0: i32,arg1: i32,) -> i32 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::bool_or(wit_bindgen::rt::bool_lift(arg0 as u8), wit_bindgen::rt::bool_lift(arg1 as u8));
    match result0 { true => 1, false => 0 }
  }
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "bool-xor"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_bool_xor(arg0: i32,arg1: i32,) -> i32 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::bool_xor(wit_bindgen::rt::bool_lift(arg0 as u8), wit_bindgen::rt::bool_lift(arg1 as u8));
    match result0 { true => 1, false => 0 }
  }
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "float32-add"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_float32_add(arg0: f32,arg1: f32,) -> f32 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::float32_add(arg0, arg1);
    wit_bindgen::rt::as_f32(result0)
  }
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "float32-sub"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_float32_sub(arg0: f32,arg1: f32,) -> f32 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::float32_sub(arg0, arg1);
    wit_bindgen::rt::as_f32(result0)
  }
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "float64-add"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_float64_add(arg0: f64,arg1: f64,) -> f64 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::float64_add(arg0, arg1);
    wit_bindgen::rt::as_f64(result0)
  }
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "float64-sub"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_float64_sub(arg0: f64,arg1: f64,) -> f64 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::float64_sub(arg0, arg1);
    wit_bindgen::rt::as_f64(result0)
  }
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "u8-add"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_u8_add(arg0: i32,arg1: i32,) -> i32 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::u8_add(arg0 as u8, arg1 as u8);
    wit_bindgen::rt::as_i32(result0)
  }
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "u8-sub"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_u8_sub(arg0: i32,arg1: i32,) -> i32 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::u8_sub(arg0 as u8, arg1 as u8);
    wit_bindgen::rt::as_i32(result0)
  }
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "u16-add"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_u16_add(arg0: i32,arg1: i32,) -> i32 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::u16_add(arg0 as u16, arg1 as u16);
    wit_bindgen::rt::as_i32(result0)
  }
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "u16-sub"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_u16_sub(arg0: i32,arg1: i32,) -> i32 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::u16_sub(arg0 as u16, arg1 as u16);
    wit_bindgen::rt::as_i32(result0)
  }
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "u32-add"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_u32_add(arg0: i32,arg1: i32,) -> i32 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::u32_add(arg0 as u32, arg1 as u32);
    wit_bindgen::rt::as_i32(result0)
  }
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "u32-sub"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_u32_sub(arg0: i32,arg1: i32,) -> i32 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::u32_sub(arg0 as u32, arg1 as u32);
    wit_bindgen::rt::as_i32(result0)
  }
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "u64-add"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_u64_add(arg0: i64,arg1: i64,) -> i64 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::u64_add(arg0 as u64, arg1 as u64);
    wit_bindgen::rt::as_i64(result0)
  }
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "u64-sub"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_u64_sub(arg0: i64,arg1: i64,) -> i64 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::u64_sub(arg0 as u64, arg1 as u64);
    wit_bindgen::rt::as_i64(result0)
  }
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "s8-add"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_s8_add(arg0: i32,arg1: i32,) -> i32 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::s8_add(arg0 as i8, arg1 as i8);
    wit_bindgen::rt::as_i32(result0)
  }
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "s8-sub"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_s8_sub(arg0: i32,arg1: i32,) -> i32 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::s8_sub(arg0 as i8, arg1 as i8);
    wit_bindgen::rt::as_i32(result0)
  }
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "s16-add"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_s16_add(arg0: i32,arg1: i32,) -> i32 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::s16_add(arg0 as i16, arg1 as i16);
    wit_bindgen::rt::as_i32(result0)
  }
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "s16-sub"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_s16_sub(arg0: i32,arg1: i32,) -> i32 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::s16_sub(arg0 as i16, arg1 as i16);
    wit_bindgen::rt::as_i32(result0)
  }
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "s32-add"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_s32_add(arg0: i32,arg1: i32,) -> i32 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::s32_add(arg0, arg1);
    wit_bindgen::rt::as_i32(result0)
  }
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "s32-sub"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_s32_sub(arg0: i32,arg1: i32,) -> i32 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::s32_sub(arg0, arg1);
    wit_bindgen::rt::as_i32(result0)
  }
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "s64-add"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_s64_add(arg0: i64,arg1: i64,) -> i64 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::s64_add(arg0, arg1);
    wit_bindgen::rt::as_i64(result0)
  }
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "s64-sub"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_s64_sub(arg0: i64,arg1: i64,) -> i64 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let result0 = <_GuestImpl as Guest>::s64_sub(arg0, arg1);
    wit_bindgen::rt::as_i64(result0)
  }
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "list-char-append"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_list_char_append(arg0: i32,arg1: i32,arg2: i32,arg3: i32,) -> i32 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let base1 = arg0;
    let len1 = arg1;
    let mut result1 = Vec::with_capacity(len1 as usize);
    for i in 0..len1 {
      let base = base1 + i * 4;
      let e1 = {
        let l0 = *((base + 0) as *const i32);
        
        wit_bindgen::rt::char_lift(l0 as u32)
      };
      result1.push(e1);
    }
    wit_bindgen::rt::dealloc(base1, (len1 as usize) * 4, 4);
    let base3 = arg2;
    let len3 = arg3;
    let mut result3 = Vec::with_capacity(len3 as usize);
    for i in 0..len3 {
      let base = base3 + i * 4;
      let e3 = {
        let l2 = *((base + 0) as *const i32);
        
        wit_bindgen::rt::char_lift(l2 as u32)
      };
      result3.push(e3);
    }
    wit_bindgen::rt::dealloc(base3, (len3 as usize) * 4, 4);
    let result4 = <_GuestImpl as Guest>::list_char_append(result1, result3);
    let ptr5 = _RET_AREA.0.as_mut_ptr() as i32;
    let vec6 = result4;
    let len6 = vec6.len() as i32;
    let layout6 = alloc::Layout::from_size_align_unchecked(vec6.len() * 4, 4);
    let result6 = if layout6.size() != 0
    {
      let ptr = alloc::alloc(layout6);
      if ptr.is_null()
      {
        alloc::handle_alloc_error(layout6);
      }
      ptr
    }else {{
      ::core::ptr::null_mut()
    }};
    for (i, e) in vec6.into_iter().enumerate() {
      let base = result6 as i32 + (i as i32) * 4;
      {
        *((base + 0) as *mut i32) = wit_bindgen::rt::as_i32(e);
      }
    }
    *((ptr5 + 4) as *mut i32) = len6;
    *((ptr5 + 0) as *mut i32) = result6 as i32;
    ptr5
  }
  
  const _: () = {
    #[doc(hidden)]
    #[export_name = "cabi_post_list-char-append"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_list_char_append(arg0: i32,) {
      let l0 = *((arg0 + 0) as *const i32);
      let l1 = *((arg0 + 4) as *const i32);
      let base2 = l0;
      let len2 = l1;
      wit_bindgen::rt::dealloc(base2, (len2 as usize) * 4, 4);
    }
  };
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "list-list-string-append"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_list_list_string_append(arg0: i32,arg1: i32,arg2: i32,arg3: i32,) -> i32 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let base6 = arg0;
    let len6 = arg1;
    let mut result6 = Vec::with_capacity(len6 as usize);
    for i in 0..len6 {
      let base = base6 + i * 8;
      let e6 = {
        let l0 = *((base + 0) as *const i32);
        let l1 = *((base + 4) as *const i32);
        let base5 = l0;
        let len5 = l1;
        let mut result5 = Vec::with_capacity(len5 as usize);
        for i in 0..len5 {
          let base = base5 + i * 8;
          let e5 = {
            let l2 = *((base + 0) as *const i32);
            let l3 = *((base + 4) as *const i32);
            let len4 = l3 as usize;
            let bytes4 = Vec::from_raw_parts(l2 as *mut _, len4, len4);
            
            wit_bindgen::rt::string_lift(bytes4)
          };
          result5.push(e5);
        }
        wit_bindgen::rt::dealloc(base5, (len5 as usize) * 8, 4);
        
        result5
      };
      result6.push(e6);
    }
    wit_bindgen::rt::dealloc(base6, (len6 as usize) * 8, 4);
    let base13 = arg2;
    let len13 = arg3;
    let mut result13 = Vec::with_capacity(len13 as usize);
    for i in 0..len13 {
      let base = base13 + i * 8;
      let e13 = {
        let l7 = *((base + 0) as *const i32);
        let l8 = *((base + 4) as *const i32);
        let base12 = l7;
        let len12 = l8;
        let mut result12 = Vec::with_capacity(len12 as usize);
        for i in 0..len12 {
          let base = base12 + i * 8;
          let e12 = {
            let l9 = *((base + 0) as *const i32);
            let l10 = *((base + 4) as *const i32);
            let len11 = l10 as usize;
            let bytes11 = Vec::from_raw_parts(l9 as *mut _, len11, len11);
            
            wit_bindgen::rt::string_lift(bytes11)
          };
          result12.push(e12);
        }
        wit_bindgen::rt::dealloc(base12, (len12 as usize) * 8, 4);
        
        result12
      };
      result13.push(e13);
    }
    wit_bindgen::rt::dealloc(base13, (len13 as usize) * 8, 4);
    let result14 = <_GuestImpl as Guest>::list_list_string_append(result6, result13);
    let ptr15 = _RET_AREA.0.as_mut_ptr() as i32;
    let vec16 = (result14.into_bytes()).into_boxed_slice();
    let ptr16 = vec16.as_ptr() as i32;
    let len16 = vec16.len() as i32;
    ::core::mem::forget(vec16);
    *((ptr15 + 4) as *mut i32) = len16;
    *((ptr15 + 0) as *mut i32) = ptr16;
    ptr15
  }
  
  const _: () = {
    #[doc(hidden)]
    #[export_name = "cabi_post_list-list-string-append"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_list_list_string_append(arg0: i32,) {
      let l0 = *((arg0 + 0) as *const i32);
      let l1 = *((arg0 + 4) as *const i32);
      wit_bindgen::rt::dealloc(l0, (l1) as usize, 1);
    }
  };
};
const _: () = {
  
  #[doc(hidden)]
  #[export_name = "string-append"]
  #[allow(non_snake_case)]
  unsafe extern "C" fn __export_string_append(arg0: i32,arg1: i32,arg2: i32,arg3: i32,) -> i32 {
    #[allow(unused_imports)]
    use wit_bindgen::rt::{alloc, vec::Vec, string::String};
    
    // Before executing any other code, use this function to run all static
    // constructors, if they have not yet been run. This is a hack required
    // to work around wasi-libc ctors calling import functions to initialize
    // the environment.
    //
    // This functionality will be removed once rust 1.69.0 is stable, at which
    // point wasi-libc will no longer have this behavior.
    //
    // See
    // https://github.com/bytecodealliance/preview2-prototyping/issues/99
    // for more details.
    #[cfg(target_arch="wasm32")]
    wit_bindgen::rt::run_ctors_once();
    
    let len0 = arg1 as usize;
    let bytes0 = Vec::from_raw_parts(arg0 as *mut _, len0, len0);
    let len1 = arg3 as usize;
    let bytes1 = Vec::from_raw_parts(arg2 as *mut _, len1, len1);
    let result2 = <_GuestImpl as Guest>::string_append(wit_bindgen::rt::string_lift(bytes0), wit_bindgen::rt::string_lift(bytes1));
    let ptr3 = _RET_AREA.0.as_mut_ptr() as i32;
    let vec4 = (result2.into_bytes()).into_boxed_slice();
    let ptr4 = vec4.as_ptr() as i32;
    let len4 = vec4.len() as i32;
    ::core::mem::forget(vec4);
    *((ptr3 + 4) as *mut i32) = len4;
    *((ptr3 + 0) as *mut i32) = ptr4;
    ptr3
  }
  
  const _: () = {
    #[doc(hidden)]
    #[export_name = "cabi_post_string-append"]
    #[allow(non_snake_case)]
    unsafe extern "C" fn __post_return_string_append(arg0: i32,) {
      let l0 = *((arg0 + 0) as *const i32);
      let l1 = *((arg0 + 4) as *const i32);
      wit_bindgen::rt::dealloc(l0, (l1) as usize, 1);
    }
  };
};
use MyWorld as _GuestImpl;
pub trait Guest {
  fn bool_and(a: bool,b: bool,) -> bool;
  fn bool_or(a: bool,b: bool,) -> bool;
  fn bool_xor(a: bool,b: bool,) -> bool;
  fn float32_add(a: f32,b: f32,) -> f32;
  fn float32_sub(a: f32,b: f32,) -> f32;
  fn float64_add(a: f64,b: f64,) -> f64;
  fn float64_sub(a: f64,b: f64,) -> f64;
  fn u8_add(a: u8,b: u8,) -> u8;
  fn u8_sub(a: u8,b: u8,) -> u8;
  fn u16_add(a: u16,b: u16,) -> u16;
  fn u16_sub(a: u16,b: u16,) -> u16;
  fn u32_add(a: u32,b: u32,) -> u32;
  fn u32_sub(a: u32,b: u32,) -> u32;
  fn u64_add(a: u64,b: u64,) -> u64;
  fn u64_sub(a: u64,b: u64,) -> u64;
  fn s8_add(a: i8,b: i8,) -> i8;
  fn s8_sub(a: i8,b: i8,) -> i8;
  fn s16_add(a: i16,b: i16,) -> i16;
  fn s16_sub(a: i16,b: i16,) -> i16;
  fn s32_add(a: i32,b: i32,) -> i32;
  fn s32_sub(a: i32,b: i32,) -> i32;
  fn s64_add(a: i64,b: i64,) -> i64;
  fn s64_sub(a: i64,b: i64,) -> i64;
  fn list_char_append(a: wit_bindgen::rt::vec::Vec::<char>,b: wit_bindgen::rt::vec::Vec::<char>,) -> wit_bindgen::rt::vec::Vec::<char>;
  fn list_list_string_append(a: wit_bindgen::rt::vec::Vec::<wit_bindgen::rt::vec::Vec::<wit_bindgen::rt::string::String>>,b: wit_bindgen::rt::vec::Vec::<wit_bindgen::rt::vec::Vec::<wit_bindgen::rt::string::String>>,) -> wit_bindgen::rt::string::String;
  fn string_append(a: wit_bindgen::rt::string::String,b: wit_bindgen::rt::string::String,) -> wit_bindgen::rt::string::String;
}

#[allow(unused_imports)]
use wit_bindgen::rt::{alloc, vec::Vec, string::String};

#[repr(align(4))]
struct _RetArea([u8; 8]);
static mut _RET_AREA: _RetArea = _RetArea([0; 8]);

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:tests"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 709] = [3, 0, 5, 116, 101, 115, 116, 115, 0, 97, 115, 109, 13, 0, 1, 0, 7, 203, 4, 1, 65, 2, 1, 65, 45, 1, 64, 1, 3, 109, 115, 103, 115, 1, 0, 3, 0, 6, 100, 98, 103, 108, 111, 103, 1, 0, 1, 64, 2, 1, 97, 127, 1, 98, 127, 0, 127, 4, 0, 8, 98, 111, 111, 108, 45, 97, 110, 100, 1, 1, 4, 0, 7, 98, 111, 111, 108, 45, 111, 114, 1, 1, 4, 0, 8, 98, 111, 111, 108, 45, 120, 111, 114, 1, 1, 1, 64, 2, 1, 97, 118, 1, 98, 118, 0, 118, 4, 0, 11, 102, 108, 111, 97, 116, 51, 50, 45, 97, 100, 100, 1, 2, 4, 0, 11, 102, 108, 111, 97, 116, 51, 50, 45, 115, 117, 98, 1, 2, 1, 64, 2, 1, 97, 117, 1, 98, 117, 0, 117, 4, 0, 11, 102, 108, 111, 97, 116, 54, 52, 45, 97, 100, 100, 1, 3, 4, 0, 11, 102, 108, 111, 97, 116, 54, 52, 45, 115, 117, 98, 1, 3, 1, 64, 2, 1, 97, 125, 1, 98, 125, 0, 125, 4, 0, 6, 117, 56, 45, 97, 100, 100, 1, 4, 4, 0, 6, 117, 56, 45, 115, 117, 98, 1, 4, 1, 64, 2, 1, 97, 123, 1, 98, 123, 0, 123, 4, 0, 7, 117, 49, 54, 45, 97, 100, 100, 1, 5, 4, 0, 7, 117, 49, 54, 45, 115, 117, 98, 1, 5, 1, 64, 2, 1, 97, 121, 1, 98, 121, 0, 121, 4, 0, 7, 117, 51, 50, 45, 97, 100, 100, 1, 6, 4, 0, 7, 117, 51, 50, 45, 115, 117, 98, 1, 6, 1, 64, 2, 1, 97, 119, 1, 98, 119, 0, 119, 4, 0, 7, 117, 54, 52, 45, 97, 100, 100, 1, 7, 4, 0, 7, 117, 54, 52, 45, 115, 117, 98, 1, 7, 1, 64, 2, 1, 97, 126, 1, 98, 126, 0, 126, 4, 0, 6, 115, 56, 45, 97, 100, 100, 1, 8, 4, 0, 6, 115, 56, 45, 115, 117, 98, 1, 8, 1, 64, 2, 1, 97, 124, 1, 98, 124, 0, 124, 4, 0, 7, 115, 49, 54, 45, 97, 100, 100, 1, 9, 4, 0, 7, 115, 49, 54, 45, 115, 117, 98, 1, 9, 1, 64, 2, 1, 97, 122, 1, 98, 122, 0, 122, 4, 0, 7, 115, 51, 50, 45, 97, 100, 100, 1, 10, 4, 0, 7, 115, 51, 50, 45, 115, 117, 98, 1, 10, 1, 64, 2, 1, 97, 120, 1, 98, 120, 0, 120, 4, 0, 7, 115, 54, 52, 45, 97, 100, 100, 1, 11, 4, 0, 7, 115, 54, 52, 45, 115, 117, 98, 1, 11, 1, 112, 116, 1, 64, 2, 1, 97, 12, 1, 98, 12, 0, 12, 4, 0, 16, 108, 105, 115, 116, 45, 99, 104, 97, 114, 45, 97, 112, 112, 101, 110, 100, 1, 13, 1, 112, 115, 1, 112, 14, 1, 64, 2, 1, 97, 15, 1, 98, 15, 0, 115, 4, 0, 23, 108, 105, 115, 116, 45, 108, 105, 115, 116, 45, 115, 116, 114, 105, 110, 103, 45, 97, 112, 112, 101, 110, 100, 1, 16, 1, 64, 2, 1, 97, 115, 1, 98, 115, 0, 115, 4, 0, 13, 115, 116, 114, 105, 110, 103, 45, 97, 112, 112, 101, 110, 100, 1, 17, 4, 1, 35, 99, 111, 109, 112, 111, 110, 101, 110, 116, 45, 109, 111, 100, 101, 108, 45, 99, 112, 112, 58, 116, 101, 115, 116, 45, 119, 97, 115, 109, 47, 116, 101, 115, 116, 115, 4, 0, 11, 11, 1, 0, 5, 116, 101, 115, 116, 115, 3, 0, 0, 0, 16, 12, 112, 97, 99, 107, 97, 103, 101, 45, 100, 111, 99, 115, 0, 123, 125, 0, 70, 9, 112, 114, 111, 100, 117, 99, 101, 114, 115, 1, 12, 112, 114, 111, 99, 101, 115, 115, 101, 100, 45, 98, 121, 2, 13, 119, 105, 116, 45, 99, 111, 109, 112, 111, 110, 101, 110, 116, 6, 48, 46, 49, 56, 46, 50, 16, 119, 105, 116, 45, 98, 105, 110, 100, 103, 101, 110, 45, 114, 117, 115, 116, 6, 48, 46, 49, 54, 46, 48];

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_section() {}
